"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatementWrapper = void 0;
var RowsWrapper_1 = require("./RowsWrapper");
var StatementWrapper = /** @class */ (function () {
    function StatementWrapper(connection, logger, json) {
        this.binds = [];
        this.rows = [];
        this.logger = logger;
        this.connection = connection;
        this.stmt = json.sqlText;
        var that = this;
        this.executed = false;
        this.executionStatus = 'unknown';
        var start = new Date();
        // data is now populated
        connection.execute({
            sqlText: json.sqlText,
            binds: json.binds,
            complete: function (err, stmt, rows) {
                that.executed = true;
                that.statement = stmt;
                var elapsed = (new Date() - start);
                if (err) {
                    that.err = new Error(err.message);
                    var errAny = err;
                    that.err['stackTraceTxt'] = err.stack;
                    that.err['state'] = errAny.sqlState;
                    that.err['code'] = errAny.code;
                    that.executionStatus = 'noerrors';
                    //var passedArgs = that.binds ? that.binds.map((x) => (x == null && "null") || (x == undefined && "undefined") || ("" + x)).join("|") : "";
                    that.logger.log({
                        level: 'error',
                        kind: 'sql',
                        message: 'Failed to execute statement',
                        reason: err.message,
                        stmt: that.stmt,
                        args: json.binds || [],
                        stack: err.stack,
                        elapsed: elapsed
                    });
                }
                else {
                    that.executionStatus = 'noerrors';
                    if (rows)
                        that.rows = rows;
                    that.logger.log({
                        level: 'info',
                        kind: 'sql',
                        message: 'successfully execute',
                        stmt: stmt.getSqlText(),
                        args: json.binds || [],
                        elapsed: elapsed
                    });
                }
            }
        });
        require('deasync').loopWhile(function () { return !that.executed; });
    }
    StatementWrapper.prototype.execute = function () {
        this.logger.log({
            level: 'info',
            message: 'executing'
        });
        if (this.err) {
            throw this.err;
        }
        this.logger.log({
            level: 'info',
            message: 'done'
        });
        return new RowsWrapper_1.RowsWrapper(this.rows, this.logger);
    };
    StatementWrapper.prototype.getColumnCount = function () {
        var _a;
        return ((_a = this.statement) === null || _a === void 0 ? void 0 : _a.getColumns().length) || 0;
    };
    StatementWrapper.prototype.getRowCount = function () {
        var _a;
        return (_a = this.statement) === null || _a === void 0 ? void 0 : _a.getNumRows();
    };
    StatementWrapper.prototype.getNumRowsAffected = function () {
        var _a;
        var affectedRows = (_a = this.statement) === null || _a === void 0 ? void 0 : _a.getNumUpdatedRows();
        return affectedRows && affectedRows > 0 || 0;
    };
    StatementWrapper.prototype.getColumnName = function (columnIdentifier) {
        var _a;
        return (_a = this.statement) === null || _a === void 0 ? void 0 : _a.getColumn(columnIdentifier).getName();
    };
    return StatementWrapper;
}());
exports.StatementWrapper = StatementWrapper;
