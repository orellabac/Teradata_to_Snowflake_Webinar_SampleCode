"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.go = exports.ProcTester = exports.goTester = exports.TestInfo = exports.metadatadir = exports.sourcedir = exports.getNewConnector = exports.Logger = void 0;
var snowflake_sdk_1 = __importDefault(require("snowflake-sdk"));
var fs_1 = __importDefault(require("fs"));
var deasync_1 = __importDefault(require("deasync"));
var SnowflakeWrapper_1 = require("./SnowflakeWrapper");
var path_1 = __importDefault(require("path"));
var winston_1 = __importDefault(require("winston"));
var myformat = winston_1.default.format.combine(winston_1.default.format.timestamp(), winston_1.default.format.align(), winston_1.default.format.printf(function (info) {
    if (info.stmt) {
        return info.timestamp + " " + info.level + ": " + info.message + " " + (info.reason || '') + " " + info.stmt + " args [" + info.args + "]";
    }
    return info.timestamp + " " + info.level + ": " + info.message;
}));
if (process.stdout.isTTY) {
    myformat = winston_1.default.format.combine(myformat, winston_1.default.format.colorize());
}
var logger = winston_1.default.createLogger({
    level: 'info',
    format: winston_1.default.format.json(),
    defaultMeta: { service: 'user-service' },
    transports: [
        //
        // - Write all logs with level `error` and below to `error.log`
        // - Write all logs with level `info` and below to `combined.log`
        //
        new winston_1.default.transports.File({ filename: 'error.log', level: 'error' }),
        new winston_1.default.transports.File({ filename: 'combined.log' }),
        new winston_1.default.transports.Console({ format: myformat })
    ],
});
exports.Logger = logger;
function getNewConnector(logger) {
    var account = process.env["SNOW_ACCOUNT"];
    var user = process.env["SNOW_USER"];
    var password = process.env["SNOW_PASSWORD"];
    var warehouse = process.env["SNOW_WAREHOUSE"];
    var database = process.env["SNOW_DATABASE"];
    var role = process.env["SNOW_ROLE"];
    // Load the Snowflake Node.js driver.
    var connected = false;
    var connecting = true;
    // Create a Connection object that we can use later to connect.
    var connection = snowflake_sdk_1.default.createConnection({
        account: account,
        username: user,
        password: password,
        database: database,
        warehouse: warehouse,
        role: role
    });
    // Try to connect to Snowflake, and check whether the connection was successful.
    connection.connect(function (err, conn) {
        connecting = false;
        if (err) {
            logger.error({ message: 'unable to connect', reason: err.message });
        }
        else {
            connected = true;
            logger.info('Successfully connected to Snowflake.');
        }
    });
    deasync_1.default.loopWhile(function () { return connecting; });
    var switched_to = false;
    connection.execute({
        sqlText: "USE DATABASE " + database,
        complete: function (err, stmt) {
            switched_to = true;
            logger.info('done trying to switch database ' + database);
        }
    });
    deasync_1.default.loopWhile(function () { return !switched_to; });
    return new SnowflakeWrapper_1.SnowflakeWrapper(connection, logger);
}
exports.getNewConnector = getNewConnector;
function removeAllReturns(str) {
    while (str.includes("\n") || str.includes(",")) {
        str = str.replace("\n", " ").replace("\r", "").replace(",", ";");
    }
    return str;
}
var csv_filter = false;
var items_not_good = {};
var filename = "nodejs.csv";
var TestInfo = /** @class */ (function () {
    function TestInfo() {
        this.itemname = "";
        this.arguments = [];
        this.requiredPath = "notset";
        this.sourcemapFile = "";
    }
    return TestInfo;
}());
exports.TestInfo = TestInfo;
function goTester(item, schema, proc, nparameters) {
}
exports.goTester = goTester;
var ProcTester = /** @class */ (function () {
    function ProcTester(item, schema, proc, nparameters, params) {
        this.testinfoResults = new TestInfo();
        var itemname = schema + "." + proc;
        this.testinfoResults.itemname = itemname;
        logger.log({ message: "Testing " + itemname, level: 'info', source: itemname });
        this.itemlogger = logger.child({ source: itemname });
        this.connector = getNewConnector(this.itemlogger);
        this.testinfoResults.arguments = params;
        this.category = item;
        this.schema = schema;
        this.proc = proc;
        this.nparameters = nparameters;
        this.params = params;
    }
    ProcTester.prototype.exec = function () {
        var itemname = this.testinfoResults.itemname;
        var csv = this.schema + "." + this.proc + "," + this.category + "," + this.schema + "," + this.proc + "," + this.nparameters + ",";
        var result = "";
        try {
            var requirePath = "" + process.cwd() + path_1.default.sep + exports.metadatadir + path_1.default.sep + this.category + path_1.default.sep + this.schema + path_1.default.sep + this.proc + ".sql.js";
            this.testinfoResults.requiredPath = requirePath;
            var sourcemapFile = requirePath + ".map";
            this.testinfoResults.sourcemapFile = sourcemapFile;
            if (fs_1.default.existsSync(sourcemapFile)) {
                var sourceMapFile = fs_1.default.readFileSync(sourcemapFile, { encoding: 'utf8', flag: 'r' });
                var sourceMapFileObj = JSON.parse(sourceMapFile);
                this.testinfoResults.originalFile = sourceMapFileObj.sources[0];
            }
            try {
                var obj = require(requirePath);
                obj.setup_connector(this.connector);
                if (this.testinfoResults.originalFile)
                    this.itemlogger.warn('File: ' + this.testinfoResults.originalFile);
                obj.fun.apply(obj, this.params);
            }
            catch (e) {
                this.testinfoResults.lastError = e;
                result = removeAllReturns(e.toString());
                this.itemlogger.log({ level: 'error', message: e.message, stack: e.stack, source: itemname });
            }
            finally {
                obj.close();
            }
            this.itemlogger.info('done');
            if (result.length == 0)
                result = "good";
        }
        catch (e) {
            this.testinfoResults.lastError = e;
            result = removeAllReturns(e.toString());
            this.itemlogger.log({ level: 'error', message: e.message, stack: e.stack, source: itemname });
        }
        var filename = "nodejs.csv";
        csv += result;
        fs_1.default.appendFileSync(filename, csv + "\n");
        return this.testinfoResults;
    };
    return ProcTester;
}());
exports.ProcTester = ProcTester;
function go(item, schema, proc, nparameters) {
    var params = Array.prototype.slice.call(arguments, 4);
    var proctester = new ProcTester(item, schema, proc, nparameters, params);
    return proctester.exec();
}
exports.go = go;
function test(item, schema, proc, nparameters) {
    var params = Array.prototype.slice.call(arguments, 4);
    var proctester = new ProcTester(item, schema, proc, nparameters, params);
    return proctester;
}
exports.test = test;
