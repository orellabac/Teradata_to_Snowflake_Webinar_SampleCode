/* <sc-procedure> DEMODB.ProcedureSample01 </sc-procedure> */
-- Error Handlers
REPLACE PROCEDURE DEMODB.ProcedureSample01(parameter1 INTEGER, SIZE INTEGER)
BEGIN
DECLARE  myLocalVariable1 INTEGER;
DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
             CALL LogErrorMacro('there was an error...');
        END;

SET INTERVAL_SIZE = CASE 
              WHEN SIZE  IS NULL THEN 5 
              WHEN SIZE  IS NOT NULL THEN 6 
              ELSE SIZE 
            END;

IF ((CASE 
        WHEN SIZE  IS NULL THEN 200
        WHEN SIZE  IS NOT NULL THEN 1 
        ELSE SIZE 
    END) > 100) THEN
        ABORT;
END IF;

SELECT * FROM DEMO_DB.TABLE1 WHERE column1 = :parameter1;

END;


/* <sc-procedure> DEMODB.ProcedureSample02 </sc-procedure> */
-- Abort Statements
REPLACE PROCEDURE DEMODB.ProcedureSample02(parameter1 INTEGER, SIZE INTEGER)
BEGIN

ABORT 'Parameter1 is invalid because it is already inside the column' 
WHERE parameter1 IN (SELECT column1 FROM TABLE1);

ABORT 'Parameter1 is invalid' 
WHERE parameter1 IN (1,3,5,7,9,11);


ABORT 'Parameter1 is invalid because ....' 
WHERE parameter1 BETWEEN 1 AND 100;

SELECT * FROM DEMO_DB.TABLE1 WHERE column1 = :parameter1;

END;


/* <sc-procedure> DEMODB.ProcedureSample03 </sc-procedure> */
-- For Cursor Loop
REPLACE PROCEDURE DEMODB.ProcedureSample03(parameter1 INTEGER, SIZE INTEGER)
BEGIN

FOR fUsgClass AS cUsgClass CURSOR FOR
    SELECT 
        column1,
        column2,
        column3
    FROM DEMO_DB.TABLE1
DO
    BEGIN
        DECLARE columnByteInt INTEGER;
        DECLARE columnInteger INTEGER;
        DECLARE columnVarchar varchar(1000);
        SET columnByteInt = fUsgClass.column1 + 1;
        SET columnInteger = fUsgClass.column2 + 1;
        SET columnVarchar = fUsgClass.column3 || 'HELLO WORLD';
        INSERT INTO TABLE1 VALUES(:columnByteInt, :columnInteger, :columnVarchar);
    END;
END FOR;

END;


/* <sc-procedure> DEMO_DB.DYNAMIC_RESULT_SETS </sc-procedure> */
-- Multiple Result Sets
REPLACE PROCEDURE DEMO_DB.DYNAMIC_RESULT_SETS()               
	DYNAMIC RESULT SETS 2
	BEGIN
    
 		DECLARE SQL_CMD,SQL_CMD_1  VARCHAR(20000) DEFAULT ' '; 

 		DECLARE RESULTSET CURSOR WITH RETURN ONLY FOR FIRSTSTATEMENT;
 		DECLARE RESULTSET1 CURSOR WITH RETURN ONLY FOR FIRSTSTATEMENT1;
		
        -------- MAIN --------
 		SET SQL_CMD='SEL * FROM DEMO_DB.EMPLOYEE';
		SET SQL_CMD_1='SEL * FROM DEMO_DB.EMPLOYEE_PHONE_INFO';
        
        -------- CURSORS --------
		PREPARE FIRSTSTATEMENT FROM SQL_CMD; 
		OPEN RESULTSET; 
 
		PREPARE FIRSTSTATEMENT1 FROM SQL_CMD_1; 
		OPEN RESULTSET1; 
	END;
	

/* <sc-procedure> DEMO_DB.CURSORS </sc-procedure> */
-- DYNAMIC SQL, ACTIVITY_COUNT, CURSOR FOR, IF/THEN, Variable
REPLACE PROCEDURE "DEMO_DB"."CURSORS"  
(
  IN "v_TargetTable" VARCHAR(300) CHARACTER SET LATIN
  )
DYNAMIC RESULT SETS 1
	
BEGIN
    
	DECLARE v_emp_id VARCHAR(50);
    DECLARE v_emp_name VARCHAR(50);
    DECLARE v_MySQLCode INTEGER;
	DECLARE v_MySQLState CHAR(5);
	DECLARE v_CNT, v_KEEPCOUNT INTEGER;
	DECLARE v_ACT_CNT INTEGER;
	DECLARE CUR1 CURSOR FOR SELECT 'EMPLOYEE' as id_el, EMP_NAME as id_la FROM DEMO_DB.EMPLOYEE;
	
	CALL DBC.SYSEXECSQL('DELETE DEMO_DB.ACT_COUNT ALL;');
	
	SET v_ACT_CNT = ACTIVITY_COUNT;
	CALL DBC.SYSEXECSQL('INSERT INTO DEMO_DB.ACT_COUNT(' || v_ACT_CNT || ',''FIRST'');');
		
	CALL DBC.SYSEXECSQL('DROP TABLE DEMO_DB.EMPLOYEE_DUPE');
	CALL DBC.SYSEXECSQL('CREATE MULTISET TABLE DEMO_DB.EMPLOYEE_DUPE AS (SELECT * FROM DEMO_DB.EMPLOYEE) WITH DATA');
	
	CALL DBC.SYSEXECSQL('UPDATE DEMO_DB.EMPLOYEE_DUPE SET EMP_NAME = ''BOB'' WHERE EMP_ID <=2');
	
	SET v_ACT_CNT = v_ACT_CNT + ACTIVITY_COUNT;
	CALL DBC.SYSEXECSQL('INSERT INTO DEMO_DB.ACT_COUNT(' || v_ACT_CNT || ',''SECOND'');');	
	
	CALL DBC.SYSEXECSQL('DELETE FROM DEMO_DB.EMPLOYEE_DUPE WHERE EMP_ID = 4');

	SET v_ACT_CNT = v_ACT_CNT + ACTIVITY_COUNT;
	CALL DBC.SYSEXECSQL('INSERT INTO DEMO_DB.ACT_COUNT(' || v_ACT_CNT || ',''THIRD'');');

	OPEN CUR1;
	
	SET v_KEEPCOUNT = v_ACT_CNT - 1;
	SET v_CNT = 1;

	WHILE (v_CNT < v_KEEPCOUNT) DO
		FETCH CUR1 INTO v_emp_id, v_emp_name;
		CALL DBC.SYSEXECSQL('ALTER TABLE ' || v_TargetTable || ' ADD AT_' || v_emp_name || ' VARCHAR(85) CHARACTER SET LATIN CASESPECIFIC;');
		CALL DBC.SYSEXECSQL('UPDATE ' || v_TargetTable || ' SET AT_' || v_emp_name || ' = (SELECT EMP_NAME FROM DEMO_DB.EMPLOYEE WHERE EMP_ID = ' || v_CNT || ');');
		SET v_CNT = v_CNT + 1;
	END WHILE;			
END;

CALL DEMO_DB.CURSORS('EMPLOYEE_DUPE');

SELECT * FROM DEMO_DB.EMPLOYEE_DUPE;

/* <sc-procedure> DEMO_DB.CREATE_INSERTS </sc-procedure> */
-- WHILE LOOP, DYNAMIC SQL, SYSTEM TABLE QUERIES, UPDATE RESTRUCTURE, IF/THEN 
REPLACE PROCEDURE DEMO_DB.CREATE_INSERTS
 (
 IN DB_NAME varchar(500), IN TBL_NAME VARCHAR(500)
-- ,OUT SSQQLL VARCHAR(10000)
 )               
	DYNAMIC RESULT SETS 1
	BEGIN
    
		DECLARE COL_NAME, SUFFIX, PREFIX, MIDDLE, PRE_STMT, COL_TYPE, PREV_COL_TYPE VARCHAR(200);
		DECLARE COL_LIST, SQL_STMT CLOB(200000);
		DECLARE SQL_CMD VARCHAR(32000);
		DECLARE COL_COUNT, NUM_COLS, COL_LEN, BIG_OBJ INTEGER;
 		DECLARE RESULTSET CURSOR WITH RETURN ONLY FOR FIRSTSTATEMENT;
	
		DECLARE CUR2 CURSOR FOR SELECT COUNT(COLUMNNAME) FROM DBC.COLUMNS 
		WHERE DATABASENAME = DB_NAME AND TABLENAME = TBL_NAME GROUP BY DATABASENAME, TABLENAME ORDER BY TABLENAME;
		
		DECLARE CUR3 CURSOR FOR SELECT TRIM(UPPER(COLUMNNAME)) FROM DBC.COLUMNS 
		WHERE DATABASENAME = DB_NAME AND TABLENAME = TBL_NAME ORDER BY DATABASENAME, TABLENAME, COLUMNNAME;
		
		DECLARE CUR4 CURSOR FOR SELECT CASE WHEN COLUMNTYPE IN ('I', 'DA') THEN 20 ELSE COLUMNLENGTH END FROM DBC.COLUMNS 
		WHERE DATABASENAME = DB_NAME AND TABLENAME = TBL_NAME ORDER BY DATABASENAME, TABLENAME, COLUMNNAME;

		DECLARE CUR5 CURSOR FOR SELECT COLUMNTYPE FROM DBC.COLUMNS 
		WHERE DATABASENAME = DB_NAME AND TABLENAME = TBL_NAME ORDER BY DATABASENAME, TABLENAME, COLUMNNAME;

		CALL DBC.SYSEXECSQL('UPDATE MOD_TBL FROM DEMO_DB.DIMACCOUNT MOD_TBL SET ACCOUNTTYPE = ''Revenue'' WHERE MOD_TBL.ACCOUNTKEY = 61;');
		CALL DBC.SYSEXECSQL('UPDATE MOD_TBL FROM DEMO_DB.DIMACCOUNT MOD_TBL SET ACCOUNTTYPE = ''Expenditures'' WHERE MOD_TBL.ACCOUNTKEY = 61;');

		OPEN CUR2;
		OPEN CUR3;
		OPEN CUR4;
		OPEN CUR5;
		
		FETCH CUR2 INTO NUM_COLS;
		FETCH CUR3 INTO COL_NAME;
		FETCH CUR4 INTO COL_LEN;
		FETCH CUR5 INTO COL_TYPE;
		SET COL_COUNT = 2;
		SET COL_LIST = '';
		SET SQL_STMT = '';
		SET BIG_OBJ = 1;
			
		WHILE (BIG_OBJ <> 0) DO
			IF (COL_TYPE = 'BO') THEN
				SET COL_COUNT = COL_COUNT + 1;			
				FETCH CUR3 INTO COL_NAME;
				FETCH CUR4 INTO COL_LEN;
				SET PREV_COL_TYPE = COL_TYPE;
				FETCH CUR5 INTO COL_TYPE;
			ELSE
				SET BIG_OBJ = 0;
			END IF;
		END WHILE;
		
		IF (COL_NAME IN ('CLASS', 'DATE', 'CLASS')) THEN
			SET COL_NAME = '"' || COL_NAME || '"';
		END IF;
		
		SET PREFIX = 'SELECT ''INSERT INTO ' || DB_NAME || '.' || TBL_NAME || '(' || COL_NAME; 
		

		SET PRE_STMT = 'CAST(OREPLACE(TRIM(COALESCE(CAST("' || COL_NAME || '" AS VARCHAR(' || COL_LEN ||')), ' || '''''' || ')), '''''''', '''''''''''') AS VARCHAR(' || COL_LEN+5 || '))';
		
		WHILE (COL_COUNT <= NUM_COLS) DO
			FETCH CUR3 INTO COL_NAME;
			IF (COL_NAME IN ('CLASS', 'DATE', 'CLASS')) THEN
				SET COL_NAME = '"' || COL_NAME || '"';
			END IF;
			FETCH CUR4 INTO COL_LEN;
			SET PREV_COL_TYPE = COL_TYPE;
			FETCH CUR5 INTO COL_TYPE;
			IF (COL_TYPE <> 'BO') THEN
				SET COL_LIST = COL_LIST || ', ' || COL_NAME;
				IF (PREV_COL_TYPE = 'PD') THEN
					SET SQL_STMT = SQL_STMT || ' || '', ';
				ELSE
					SET SQL_STMT = SQL_STMT || ' || '''''', ';
				END IF;
				IF (COL_TYPE = 'PD') THEN
					SET SQL_STMT = SQL_STMT || 'PERIOD (DATE'''''' || CAST(BEGIN(' || COL_NAME || ') AS VARCHAR(10)) || '''''', DATE '''''' || CAST(END(' || COL_NAME || ')AS VARCHAR(10)) || '''''')''';
				ELSE 
					SET SQL_STMT = SQL_STMT || ''''''' || CAST(OREPLACE(TRIM(COALESCE(CAST("' || COL_NAME || '" AS VARCHAR(' || COL_LEN ||')), ' || '''''' || ')), '''''''', '''''''''''') AS VARCHAR(' || COL_LEN+5 || '))' ;
				END IF;
			END IF;
			SET COL_COUNT = COL_COUNT + 1;	
		END WHILE;	

		SET SUFFIX = ' || '''''');'' "--"  FROM ' || DB_NAME || '.' || TBL_NAME || ';';
		SET MIDDLE = ') VALUES('''''' || ';
		SET SQL_CMD = PREFIX || COL_LIST || MIDDLE || PRE_STMT || SQL_STMT || SUFFIX;

--		SET SSQQLL = SQL_CMD;	
		PREPARE FIRSTSTATEMENT FROM SQL_CMD; 
		OPEN RESULTSET; 
	END;